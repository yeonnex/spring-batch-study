# 잡 (Job)
- _Job.class_: 실제로 잡을 구동한다. 잡 실행시 Job 인스턴스가 실행된다. </br>
아래 3개의 클래스들은 잡 구동시 메타 데이터를 저장하기 위해 사용되는 클래스들이다.  
- _JobInstance.class_
- _JobParameters.class_
- _JobExecution.class_

## Job.class
1. 개념
- 하나의 배치작업 자체를 의미
  - ex) "API 서버의 접속 로그 데이터를 통계 서버로 옮기는 배치"
- 배치작업을 어떻게 구성하고 실행할 것인지 전체적으로 설정하고 명세해 놓은 객체
- 배치 Job 을 구성하기 위한 최상위 인터페이스이며 스프링 배치가 기본 구현체 제공
- 여러 Step 을 포함하고 있는 컨테이너로서 반드시 한 개 이상의 Step 으로 구성
  - ```java
    public class SimpleJob extends AbstractJob {
    
	        private List<Step> steps = new ArrayList<>();
            ...
    }
    ```
2. 기본 구현체
- SimpleJob
  - 순차적으로 Step 을 실행시키는 Job
    - ex) step1 ---> step2 ---> step3
- FlowJob
  - 특정 조건에 따라 step 이 실행되는 Job
  - step1 ---> if (condition...) {step2 스킵} ---> step3
  - Flow 객체를 실행시켜 작업을 진행

## JobInstance.class
1. 개념
- 예를 들어 하루에 한번씩 잡이 실행된다면 매일 실행되는 그날의 Job 을 JobInstance 로 표현
2. JobInstance 생성 및 실행
- 한번도 저장되지 않은 Job + JobParameter 인지 DB 에서 조회하여 확인한다
- 그렇다면 새로운 JobInstace 를 생성한다
- 아니라면 (이전에 동일한 Job + JobParameter 로 배치를 실행한 적이 있다면) 이미 존재하는 JobInstance 를 리턴한다
  - 내부적으로는 jobName + jobKey (jobParameters 의 해시값) 를 가지고 JobInstance 객체를 얻는다
- Job 과는 1 : M 관계
3. `BATCH_JOB_INSTANCE` 테이블과 매핑

### JobExecution.class
1. 개념
- JobInstance 에 대한 한번의 시도를 의미하는 객체로서 Job 실행 중에 발생한 정보를 저장하고 있는 객체
- 시작시간, 종료시간, 상태(시작됨, 완료, 실패), 종료상태의 속성을 가짐
- **FAILED**, **COMPLETED** 등의 잡 실행 결과 상태를 가지고 있음
- 실행 결과가 **COMPLETED** 라면 해당 잡 인스턴스를 성공적으로 완료했음을 의미하므로 _재실행 불가_
- 실행 결과가 **FAILED** 라면 해당 잡 인스턴스를 처리하는데 실패했음을 의미하므로 _재실행 가능_
  - 예외) 잡 파라미터가 없는 경우 **COMPLETED** 일지라도 매 실행마다 ROW 가 쌓임
- 스텝이 두개가 있다면, 둘 중에 하나라도 실패하면 잡 전체는 실패. 잡 실행 재시도시, 만약 가장 처음 스텝은 성공했으나 두번쨰 스텝에서 실패했다면 처음 스텝은 이미 성공했으므로 건너뛰고 두번쨰 스텝만을 실행 (StepExecution)
  - Step.class 의 추상 구현체인 AbstractJob.class 의 `allowStartIfComplete` 값의 기본값이 _false_  이기 떄문
  - `allowStartIfComplete = true`로 설정한다면 이미 성공한 스텝도 재실행하게 할 수 있음
2. `BATCH_JOB_EXECUTION` 테이블과 매핑
- JobInstance 와 1 : M 관계

### Step.class
1. 개념
- 잡을 구성하는 독립적인 하나의 단계이자 객체
- 단순한 단일 태스크 처리 뿐만 아니라 입력과 처리, 그리고 출력과 관련된 복잡한 비즈니스 로직을 포함하는 모든 설정 포함
- 모든 Job 은 하나 이상의 step 으로 구성됨
- Job 이 Step 을 실행하고, Step 이 Tasklet 을 실행하는 구조
2. 스프링에서 제공하는 기본 구현체
- **TaskletStep**
  - 가장 기본이 되는 클래스. Tasklet 타입의 구현체
- **PartitionStep**
  - 멀티스레드 방식으로 Step 을 여러 개로 분리해서 실행
- **JobStep**
  - Step 내에서 Job 을 실행
    - ex) step1 실행 -> step1 내에서 현재 잡이 아닌 미리 정의해 놓은 다른 잡 실행 -> step1 내에서 정의해놓은 잡의 스텝 실행 ...
- **FlowStep**
  - Step 내에서 Flow 를 실행
### API 설정에 따른 각 Step 설정
**1. TaskletStep (기본) : 직접 생성한 Tasklet 실행**
```java
public Step taskletStep() {
    return this.stepBuilderFactory.get("step")
        .tasklet(myTasklet())
        .build();
}
```
**2. TaskletStep (청크기반) : ChunkOrientedTasklet 을 실행**
```java
public Step taskletStep() {
    return stepBuilderFactory.get("step")
        .<Member,Member>chunk(100)
        .reader(reader())
        .writer(writer())
        .build();
}
```
**3. JobStep : Step 에서 Job 을 실행**
```java
public Step jobStep() {
    return stepBuilderFactory.get("step")
        .job(job())
        .launcher(jobLauncher())
        .parametersExtractor(jobParametersExtractor())
        .build();
}
```
**4. FlowStep : Step 에서 Flow 를 실행**
```java
public Step flowStep() {
    return stepBuilderFactory.get("step")
        .flow(myFlow())
        .build();
}
```